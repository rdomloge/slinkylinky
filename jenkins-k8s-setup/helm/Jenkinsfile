pipeline {
    
    agent { label "helm-worker" }

    environment {
        BUILDER = 'mybuilder'
        FOLDER = "${WORKSPACE}/jenkins-k8s-setup/helm"
    }

    stages {
        stage('Checkout') {
            steps {
                withFolderProperties() {
                    git branch: 'main', url: "https://${env.GITHUB_PERSONAL_ACCESS_TOKEN}@github.com/rdomloge/sl-k8s-scripts.git"
                }
            }
        }

        stage('Generate tenant name') {
            steps {
                script {
                    // Generate a unique tenant name using 3 chars followed by 5 numbers
                    env.TENANT = sh(
                        script: "cat /dev/urandom | tr -dc 'a-z' | head -c3; cat /dev/urandom | tr -dc '0-9' | head -c5",
                        returnStdout: true
                    ).trim()
                    echo "Generated tenant name: ${env.TENANT}"
                }
            }
        }

        stage('Generate Password') {
            steps {
                script {
                    // Generate a 24-character base64 password (strong and URL-safe)
                    env.LINKSERVICE_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    env.KEYCLOAK_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    env.STATS_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    // Optional: verify variable exists but don't echo it
                    echo "Password generated and stored in env var (not printing it for security)"
                    
                    echo "LINKSERVICE_DB_PASSWORD: ${env.LINKSERVICE_DB_PASSWORD}"
                    echo "KEYCLOAK_DB_PASSWORD: ${env.KEYCLOAK_DB_PASSWORD}"
                }
            }
        }

        stage('Deploy platform via Helm') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            helm install \\
                            --generate-name \\
                            ${FOLDER} \\
                            --set tenant=${TENANT} \\
                            --set LINKSERVICE_DB_PASSWORD=${LINKSERVICE_DB_PASSWORD} \\
                            --set KEYCLOAK_DB_PASSWORD=${KEYCLOAK_DB_PASSWORD} \\
                            --set STATS_DB_PASSWORD=${STATS_DB_PASSWORD}
                            '''
                        }
                    }
                }
            }
        }

        stage('Update secrets in Kubernetes') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            # Update the existing db-connection-secret created by Helm
                            kubectl -n ${TENANT} patch secret db-connection-secret \\
                              --type='merge' \\
                              -p='{
                                "data": {
                                  "LINKSERVICE_DB_PASSWORD": "'$(echo -n "${LINKSERVICE_DB_PASSWORD}" | base64 -w 0)'",
                                  "KC_DB_PASSWORD": "'$(echo -n "${KEYCLOAK_DB_PASSWORD}" | base64 -w 0)'",
                                  "STATS_DB_PASSWORD": "'$(echo -n "${STATS_DB_PASSWORD}" | base64 -w 0)'"
                                }
                              }'
                            
                

                            # Also update keycloak-credentials secret if it exists
                            if kubectl -n ${TENANT} get secret keycloak-credentials >/dev/null 2>&1; then
                                kubectl -n ${TENANT} patch secret keycloak-credentials \\
                                  --type='merge' \\
                                  -p='{"data":{"KC_DB_PASSWORD":"'$(echo -n "${KEYCLOAK_DB_PASSWORD}" | base64 -w 0)'"}}'
                            fi
                            '''
                        }
                    }
                }
            }
        }

        stage('Create tunnel in Cloudflare') {
            steps {
                script {
                    withFolderProperties() {
                        sh """
                        curl -s \\
                        -X POST \\
                        -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \\
                        -H "Content-Type: application/json" \\
                        -d '{
                          "name": "${TENANT}",
                          "config_src": "cloudflare"
                        }' \\
                        https://api.cloudflare.com/client/v4/accounts/a3f61764f4abaee7c31e8ec3343172cd/cfd_tunnel \\
                         > response.json
                        """
                        // Extract the tunnel secret from the credentials file
                        env.TUNNEL_SECRET = sh(
                            script: "jq -r '.result.credentials_file.TunnelSecret' response.json",
                            returnStdout: true
                        ).trim()
                        // Extract the tunnel ID from the credentials file
                        env.TUNNEL_ID = sh(
                            script: "jq -r '.result.credentials_file.TunnelID' response.json",
                            returnStdout: true
                        ).trim()
                        // Extract the token from the credentials file
                        env.TUNNEL_TOKEN = sh(
                            script: "jq -r '.result.token' response.json",
                            returnStdout: true
                        ).trim()
                        // delete response.json to clean up
                        sh 'rm -f create-tunnel-response.json'
                    }
                }
            }
        }

        stage('Setup tunnel routes & DNS') {
            steps {
                script {
                    withFolderProperties() {
                        // ROUTES
                        sh """
                            curl -s \\
                            -X PUT \\
                            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \\
                            -H "Content-Type: application/json" \\
                            -d '{
                                "config": {
                                    "ingress": [
                                        {
                                            "hostname": "${TENANT}.slinkylinky.uk",
                                            "service": "http://adminwebsite-service:3000",
                                            "originRequest": {}
                                        },
                                        {
                                            "service": "http_status:404"
                                        }
                                    ]
                                }
                            }' \\
                            https://api.cloudflare.com/client/v4/accounts/a3f61764f4abaee7c31e8ec3343172cd/cfd_tunnel/${TUNNEL_ID}/configurations \\
                            > tunnel-routes-response.json
                        """
                        // DNS
                        sh """
                            curl -s \\
                            -X POST \\
                            -H "Authorization: Bearer ${CLOUDFLARE_API_TOKEN}" \\
                            -H "Content-Type: application/json" \\
                            -d '{
                                    "type": "CNAME",
                                    "proxied": true,
                                    "name": "${TENANT}.slinkylinky.uk",
                                    "content": "${TUNNEL_ID}.cfargotunnel.com"
                                }' \\
                            https://api.cloudflare.com/client/v4/zones/93230fb6cec6bbe6ca142e2d20c945c9/dns_records \\
                            > tunnel-dns-response.json
                        """
                        
                    }
                }
            }
        }

        stage('Store the tunnel token as a K8S secret') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            # Create or update the cloudflared-tunnel-secret in Kubernetes
                            kubectl -n ${TENANT} create secret generic cloudflared-tunnel-secret \\
                              --from-literal=token="${TUNNEL_TOKEN}" \\
                              --dry-run=client -o yaml | kubectl apply -f -
                            '''
                        }
                    }
                }
            }
        }


        stage('Run cloudflare tunnel') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            cat <<EOF | kubectl -n ${TENANT} apply -f -
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cloudflared-tunnel
  namespace: ${TENANT}
spec:
  serviceName: cloudflared
  replicas: 1
  selector:
    matchLabels:
      app: cloudflared
      version: v1
  template:
    metadata:
      labels:
        app: cloudflared
        version: v1
    spec:
      containers:
        - name: cloudflared
          image: cloudflare/cloudflared:latest
          imagePullPolicy: Always
          command: 
            - cloudflared
            - tunnel
            - --no-autoupdate
            - --loglevel
            - debug
            - --metrics
            - 0.0.0.0:2000
            - run
          livenessProbe:
            httpGet:
              path: /ready
              port: 2000
            initialDelaySeconds: 10
            failureThreshold: 3
            periodSeconds: 10
          env:
            - name: TUNNEL_TOKEN
              valueFrom:
                secretKeyRef:
                  name: cloudflared-tunnel-secret
                  key: token
          resources:
            requests:
              cpu: "100m"
              memory: "200Mi"
            limits:
              cpu: "500m"
              memory: "500Mi"
EOF
                            '''
                        }
                    }
                }
            }
        }

        stage('Post-install config updates') {
            steps {
                script {
                    // Update the admin-website-config ConfigMap with the external URL
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh """
                            # Update the admin-website-config ConfigMap with the external URL
                            kubectl -n ${TENANT} patch configmap admin-website-config \\
                              --type='merge' \\
                              -p='{"data":{"NEXTAUTH_URL":"https://${TENANT}.slinkylinky.uk"}}'
                            """
                        }
                    }
                    // Update the admin-website-config ConfigMap  NEXTAUTH_URL with the external URL
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh """
                            # Update the admin-website-config ConfigMap NEXTAUTH_URL with the external URL
                            kubectl -n ${TENANT} patch configmap admin-website-config \\
                              --type='merge' \\
                              -p='{"data":{"NEXTAUTH_URL":"https://${TENANT}.slinkylinky.uk"}}'
                            """
                        }
                    }

                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh """
                                kubectl -n ${TENANT} patch secret keycloak-credentials \\
                                  --type='merge' \\
                                  -p='{"data": {"KEYCLOAK_ISSUER": "banana"}}'
                            """
                            // sh """
                            // # Update the keycloak-credentials with the correct URLs
                            // kubectl -n ${TENANT} patch secret keycloak-credentials \\
                            //   --type='merge' \\
                            //   -p='{
                            //     "data": {
                            //       "KEYCLOAK_ISSUER": "'$(echo -n "https://${TENANT}.slinkylinky.uk/realms/${TENANT}" | base64 -w 0)'",
                            //       "JWK_SET_URI": "'$(echo -n "https://${TENANT}.slinkylinky.uk/realms/${TENANT}/protocol/openid-connect/certs" | base64 -w 0)'",
                            //       "KEYCLOAK_CLIENTCREDENTIALS_TOKEN_URI": "'$(echo -n "/realms/${TENANT}/protocol/openid-connect/token" | base64 -w 0)'"
                            //     }
                            //   }'
                            // """
                        }
                    }

                    // // The CLIENTCREDENTIALS stuff is for server-to-server auth
                    // // Connect to the Keycloak API and create the TENANT realm if it doesn't exist
                    // withFolderProperties() {
                    //     withKubeConfig(credentialsId: 'prod-k8s', 
                    //                     serverUrl: "${env.K8S_SERVER_URL}") {

                    //         sh '''
                    //         # Create a port-forward to Keycloak service
                    //         kubectl -n ${TENANT} port-forward svc/keycloak-service 8080:8080 &
                    //         KUBE_PID=$!


                    //         # Fetch admin access token
                    //         ADMIN_TOKEN=$(curl -s -X POST "https://localhost:8080/realms/master/protocol/openid-connect/token" \\
                    //         -H "Content-Type: application/x-www-form-urlencoded" \\
                    //         -d "grant_type=password&client_id=admin-cli&username=admin&password=admin")

                    //         # Create realm
                    //         curl -s -X POST -H "Authorization: Bearer $ADMIN_TOKEN" -H "Content-Type: application/json" \\
                    //         -d '{"realm": "'${TENANT}'", "enabled": true}' \\
                    //         "https://localhost:8080/admin/realms"

                    //         # Create client credentials client
                    //         curl -s -X POST -H "Authorization: Bearer $ADMIN_TOKEN" -H "Content-Type: application/json" \\
                    //         -d '{"clientId": "sl-webapp", "enabled": true, "publicClient": false, "secret": "client-secret"}' \\
                    //         "https://localhost:8080/admin/realms/${TENANT}/clients"

                    //         # Kill the port-forward
                    //         kill $KUBE_PID

                    //         '''
                    //     }
                    // }
                }
            }
        }
    }
}