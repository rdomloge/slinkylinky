pipeline {
    
    agent { label "helm-worker" }

    environment {
        BUILDER = 'mybuilder'
        FOLDER = "${WORKSPACE}/jenkins-k8s-setup/helm"
    }

    stages {
        stage('Checkout') {
            steps {
                withFolderProperties() {
                    git branch: 'main', url: "https://${env.GITHUB_PERSONAL_ACCESS_TOKEN}@github.com/rdomloge/sl-k8s-scripts.git"
                }
            }
        }

        stage('Generate tenant name') {
            steps {
                script {
                    // Generate a unique tenant name using 3 chars followed by 5 numbers
                    env.TENANT = sh(
                        script: "cat /dev/urandom | tr -dc 'a-z' | head -c3; cat /dev/urandom | tr -dc '0-9' | head -c5",
                        returnStdout: true
                    ).trim()
                    echo "Generated tenant name: ${env.TENANT}"
                }
            }
        }

        stage('Generate Password') {
            steps {
                script {
                    // Generate a 24-character base64 password (strong and URL-safe)
                    env.LINKSERVICE_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    env.KEYCLOAK_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    env.STATS_DB_PASSWORD = sh(
                        script: "openssl rand -base64 24 | tr -d '\\n'",
                        returnStdout: true
                    ).trim()

                    // Optional: verify variable exists but don't echo it
                    echo "Password generated and stored in env var (not printing it for security)"
                    
                    echo "LINKSERVICE_DB_PASSWORD: ${env.LINKSERVICE_DB_PASSWORD}"
                    echo "KEYCLOAK_DB_PASSWORD: ${env.KEYCLOAK_DB_PASSWORD}"
                }
            }
        }

        stage('Deploy platform via Helm') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            helm install \\
                            --generate-name \\
                            ${FOLDER} \\
                            --set tenant=${TENANT} \\
                            --set LINKSERVICE_DB_PASSWORD=${LINKSERVICE_DB_PASSWORD} \\
                            --set KEYCLOAK_DB_PASSWORD=${KEYCLOAK_DB_PASSWORD} \\
                            --set STATS_DB_PASSWORD=${STATS_DB_PASSWORD}
                            '''
                        }
                    }
                }
            }
        }

        stage('Update secrets in Kubernetes') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            # Update the existing db-connection-secret created by Helm
                            kubectl -n ${TENANT} patch secret db-connection-secret \\
                              --type='merge' \\
                              -p='{
                                "data": {
                                  "LINKSERVICE_DB_PASSWORD": "'$(echo -n "${LINKSERVICE_DB_PASSWORD}" | base64 -w 0)'",
                                  "KC_DB_PASSWORD": "'$(echo -n "${KEYCLOAK_DB_PASSWORD}" | base64 -w 0)'",
                                  "STATS_DB_PASSWORD": "'$(echo -n "${STATS_DB_PASSWORD}" | base64 -w 0)'"
                                }
                              }'
                            
                

                            # Also update keycloak-credentials secret if it exists
                            if kubectl -n ${TENANT} get secret keycloak-credentials >/dev/null 2>&1; then
                                kubectl -n ${TENANT} patch secret keycloak-credentials \\
                                  --type='merge' \\
                                  -p='{"data":{"KC_DB_PASSWORD":"'$(echo -n "${KEYCLOAK_DB_PASSWORD}" | base64 -w 0)'"}}'
                            fi
                            '''
                        }
                    }
                }
            }
        }

        stage('Create tunnel in Cloudflare') {
            // In this stage, we create a Cloudflare tunnel using the TENANT variable as the sub-domain of slinkylinky.uk
            // This stage runs on the cloudflared-worker agent to ensure cloudflared is available
            // Running the commands results in a JSON credentials file being created in the worker's home directory 
            agent { label "cloudflared-worker" }

            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            # Create Cloudflare tunnel for the tenant
                            cloudflared tunnel create ${TENANT}-tunnel

                            # Configure the tunnel (assuming config file is pre-defined)
                            cloudflared tunnel route dns ${TENANT}-tunnel ${TENANT}.slinkylinky.uk

                            # Start the tunnel (this may need to be run as a background process or service)
                            cloudflared tunnel run ${TENANT}-tunnel &
                            '''

                            // store the TUNNEL_ID in an environment variable for later use
                            env.TUNNEL_ID = sh(
                                script: '''
                                cloudflared tunnel list | grep ${TENANT}-tunnel | awk '{print $1}'
                                ''',
                                returnStdout: true
                            ).trim()

                            // Assuming the tunnel credentials file is located at /etc/cloudflared/<tunnel-id>.json
                            // Load the cloudflared tunnel secret into a variable

                            env.TUNNEL_SECRET = sh(
                                script: '''
                                CLOUDFLARED_CREDENTIALS_FILE="/etc/cloudflared/${TUNNEL_ID}.json"
                                echo "$(jq -r '.TunnelSecret' ${CLOUDFLARED_CREDENTIALS_FILE})"
                                ''',
                                returnStdout: true
                            ).trim()

                            // Delete the JSON credentials file from the worker for security
                            // sh '''
                            // rm -f "/etc/cloudflared/${TUNNEL_ID}.json"
                            //  '''
                        }
                    }
                }
            }
        }

        stage('Store the cloudflared tunnel secret as a Kubernetes secret') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh '''
                            # Create or update the cloudflared-tunnel-secret in Kubernetes
                            kubectl -n ${TENANT} create secret generic cloudflared-tunnel-secret \\
                              --from-literal=token="${TUNNEL_SECRET}" \\
                              --dry-run=client -o yaml | kubectl apply -f -
                            '''
                        }
                    }
                }
            }
        }

        stage('Run cloudflared tunnel as a deployment') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh """
                            # Create a Kubernetes deployment for cloudflared tunnel
                            kubectl -n \${TENANT} apply -f - <<EOF
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: cloudflared-\${TENANT}-tunnel
  namespace: \${TENANT}
spec:
  serviceName: cloudflared
  replicas: 1
  selector:
    matchLabels:
      app: cloudflared
      version: v1
  template:
    metadata:
      labels:
        app: cloudflared
        version: v1
    spec:
      containers:
        - name: cloudflared
          image: cloudflare/cloudflared:latest
          imagePullPolicy: Always
          command: 
            - cloudflared
            - tunnel
            - --metrics
            - 0.0.0.0:2000
            - run
          args: ["--token", "$(token-value)"]
          livenessProbe:
            httpGet:
              path: /ready
              port: 2000
            initialDelaySeconds: 10
            failureThreshold: 3
            periodSeconds: 10
          env:
            - name: token-value
              valueFrom:
                secretKeyRef:
                  name: cloudflared-tunnel-secret
                  key: token
          resources:
            requests:
              cpu: "100m"
              memory: "200Mi"
            limits:
              cpu: "500m"
              memory: "500Mi"
EOF
                            """
                        }
                    }
                }
            }
        }

        stage('Update external URI in adminwebsite configmap') {
            steps {
                script {
                    withFolderProperties() {
                        withKubeConfig(credentialsId: 'prod-k8s', 
                                        serverUrl: "${env.K8S_SERVER_URL}") {

                            sh """
                            # Update the admin-website-config ConfigMap with the external URL
                            kubectl -n ${TENANT} patch configmap admin-website-config \\
                              --type='merge' \\
                              -p='{"data":{"NEXTAUTH_URL":"https://${TENANT}.slinkylinky.uk"}}'
                            """
                        }
                    }
                }
            }
        }
    }
}